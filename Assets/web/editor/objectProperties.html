<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SPP</title>
        <meta charset="utf-8">
		
		<link rel="stylesheet" href="./fontawesome/css/all.css">       
        <script type="text/javascript" src="./jQuery/jquery-3.5.1.js"></script>		
				
	<style>
	
	
	input[type=text] {
	  width: 30px;
	  box-sizing: border-box;
	}
	

	.styled-table {
		background: #222222;
		border-collapse: collapse;		
		font-size: 0.9em;
		font-family: Arial Narrow,Arial,sans-serif; 
		min-width: 100px;	
		color: #ffffff;	
		width: 100%;
	}
	
	.styled-table tr td:first-child {
		width: 1%;
		white-space: nowrap;
	}
		
	.alnright { text-align: right; }
	
	.styled-table thead tr {
		background-color: #009879;
		color: #ffffff;
		text-align: left;
	}

	
	.styled-table tbody td:first-of-type {
		border-right: 1px solid #000000;
		vertical-align: top;
	}


	.styled-table a:hover {
	  background-color: black;
	}
	
	/* unvisited link */
	.styled-table	a:link {
		  color: white;
		}

		/* visited link */
	.styled-table	a:visited {
		  color: white;
		}


    </style>

    </head>
    <body>
		
	<div id='objProp'></div>
	
	<!-- <input type="color" id="head" name="head"  value="#e66465"> -->
	<script>
	
	var NativeTypesPoD = {
		"float" : "Number",
		"double" : "Number",
		"int8_t" : "Number",
		"uint8_t" : "Number",
		"int16_t" : "Number",
		"uint16_t" : "Number",
		"int32_t" : "Number",
		"uint32_t" : "Number",
		"int64_t" : "Number",
		"uint64_t" : "Number",
		"bool" : "Bool"
	};
	
	function AppendPath(InValue, CurPath)
	{
		if(CurPath.length == 0)
		{
			return InValue;
		}
		else
		{
			return CurPath + "." + InValue;
		}	
	}
	
	function NativeStructToInput(memberElement, subTypes, tableCol, curPath) {
	
		var tbl = document.createElement('table');		
		var tbdy = document.createElement('tbody');
		
		tbl.setAttribute("class", "styled-table");
		
		memberElement.value.forEach(function(memberData) {					
			NativeTypeToInput(memberData, subTypes, tbdy, AppendPath(memberElement.name, curPath));	
		});
		
		tbl.appendChild(tbdy);
		tableCol.appendChild(tbl);
	}
	
	function NativeEnumToInput(memberElement, subTypeEnum, tableCol, curPath) {
		
		var eumSelect = document.createElement("SELECT");
		eumSelect.setAttribute("id", memberElement.name + "EVALUE");		
		eumSelect.propPath = AppendPath(memberElement.name, curPath);
			
		subTypeEnum.values.forEach(function(curValue) {	
			var curOpt = document.createElement("option");
			curOpt.setAttribute("value", curValue);
			var txtNode = document.createTextNode(curValue);
			curOpt.appendChild(txtNode);

			eumSelect.appendChild(curOpt);
		});
				
		eumSelect.value = memberElement.value;
		
		tableCol.appendChild(eumSelect);
	}
	
	function NativeTypeToInput(memberElement, subTypes, tableBody, curPath)
	{
		let memberyTypeName = memberElement.type;
		//console.log("memberyTypeName: " + memberyTypeName);
		
		if( memberyTypeName in NativeTypesPoD )
		{
			//console.log(" POD");
			
			var tr = document.createElement('tr');
			var tdN = document.createElement('td');
			var tdV = document.createElement('td');
						
			tdN.setAttribute("class", "alnright");
			tdN.appendChild(document.createTextNode(memberElement.name));
	
			var x = document.createElement("a");
			x.setAttribute("data-editable", "true");
			x.setAttribute("href", "#");
			x.dataType = NativeTypesPoD[memberyTypeName];
			//x.setAttribute("type", "text");
			//x.setAttribute("value", memberElement.value);
			//x.propPath = AppendPath(memberElement.name, curPath);
			
			const textNode = document.createTextNode(memberElement.value);
			//textNode.setAttribute("href", "#");
			x.appendChild(textNode);
			
			if(NativeTypesPoD[memberyTypeName] == "Number")
			{
				setInputFilter(x, function(value) {
				  return /^-?\d*\.?\d*$/.test(value); // Allow digits and '.' only, using a RegExp
				});
			}

			tdV.appendChild(x);
			
			tr.appendChild(tdN);
			tr.appendChild(tdV);
			
			tableBody.appendChild(tr);
		}
		else if( memberyTypeName in subTypes )
		{
			let curSubType = subTypes[memberyTypeName];		
							
			var tr = document.createElement('tr');
			var tdN = document.createElement('td');
			var tdV = document.createElement('td');
			
			tdN.setAttribute("class", "alnright");
			tdN.appendChild(document.createTextNode(memberElement.name));
				
			//console.log(" SUB");
			if( curSubType.type == "enum" )
			{
				//console.log("ENUM");				
				NativeEnumToInput(memberElement, curSubType, tdV, curPath);
			}
			else
			{
				//console.log(" SUB");
				NativeStructToInput(memberElement, subTypes, tdV, curPath);				
			}
			
			tr.appendChild(tdN);
			tr.appendChild(tdV);
				
			tableBody.appendChild(tr);
		}
	}
	
	function generateObjTable(divID, TableData, subTypes) {
		$(divID).empty();
		
		var tbl = document.createElement('table');		
		var tbdy = document.createElement('tbody');
		
		tbl.setAttribute("class", "styled-table");
	
		TableData.forEach(function(memberData) {					
			NativeTypeToInput(memberData, subTypes, tbdy, "");	
		});
		
		tbl.appendChild(tbdy);
		
		$(divID).append(tbl);
	}
	
	
		
	var subTypeInfo =  String.raw`{
		"Vector3" : { 
			"type" : "struct"	
		},
		"EShapeOp" : {
				"type" : "enum",
				"values" : 
				[
					"Add",
					"Subtract",
					"Intersect",
					"SmoothAdd"
				]
		}		
	}`;
	
	const subTypeObj = JSON.parse(subTypeInfo);
	
	var objectDataInfo = String.raw`[
		{
			"name" : "_translation",
			"type" : "Vector3",
			"value" : 
			[
				{
					"name" : "x",
					"type" : "float",
					"value" : "0"
				},
				{
					"name" : "y",
					"type" : "float",
					"value" : "0"
				},
				{
					"name" : "z",
					"type" : "float",
					"value" : "0"
				}
			]
		},
		{
			"name" : "_rotation",
			"type" : "Vector3",
			"value" : 
			[
				{
					"name" : "x",
					"type" : "float",
					"value" : "0"
				},
				{
					"name" : "y",
					"type" : "float",
					"value" : "0"
				},
				{
					"name" : "z",
					"type" : "float",
					"value" : "0"
				}
			]
		},
		{
			"name" : "_scale",
			"type" : "float",
			"value" : "1"
		},
		{
			"name" : "_shapeOp",
			"type" : "EShapeOp",
			"value" : "Add"
		},
		{
			"name" : "_extents",
			"type" : "Vector3",
			"value" : 
			[
				{
					"name" : "x",
					"type" : "float",
					"value" : "1"
				},
				{
					"name" : "y",
					"type" : "float",
					"value" : "1"
				},
				{
					"name" : "z",
					"type" : "float",
					"value" : "1"
				}
			]
		}
	]`;
	
	/**
	  We're defining the event on the `body` element, 
	  because we know the `body` is not going away.
	  Second argument makes sure the callback only fires when 
	  the `click` event happens only on elements marked as `data-editable`
	*/
	$('body').on('click', '[data-editable]', function(){
	  
	  var $el = $(this);

	  var StoredDataType = this.dataType;
	  console.log("StoredDataType" + StoredDataType);
	  
	  var $input = $('<input/>').val( $el.text() );
	  $el.replaceWith( $input );
	  
	  
	  
	  var save = function(){
		var $p = $('<div data-editable /><a href="#" />').text( $input.val() );
		$input.replaceWith( $p );
	  };
	  
	  /**
		We're defining the callback with `one`, because we know that
		the element will be gone just after that, and we don't want 
		any callbacks leftovers take memory. 
		Next time `p` turns into `input` this single callback 
		will be applied again.
	  */
	  $input.one('blur', save).focus();
	  
	});
	
	const objectData = JSON.parse(objectDataInfo);	
	generateObjTable("#objProp",objectData,subTypeObj);
	
	
	// Restricts input for the given textbox to the given inputFilter function.
	function setInputFilter(textbox, inputFilter) {
	  ["input", "keydown", "keyup", "mousedown", "mouseup", "select", "contextmenu", "drop"].forEach(function(event) {
		textbox.addEventListener(event, function() {
		  if (inputFilter(this.value)) {
			this.oldValue = this.value;
			this.oldSelectionStart = this.selectionStart;
			this.oldSelectionEnd = this.selectionEnd;
		  } else if (this.hasOwnProperty("oldValue")) {
			this.value = this.oldValue;
			this.setSelectionRange(this.oldSelectionStart, this.oldSelectionEnd);
		  } else {
			this.value = "";
		  }
		});
	  });
	}

	$(document).on("keypress", "input", function(e){
        if(e.which == 13){
			//unselect
			$(this).blur();			
			
			if("propPath" in this)
			{
				console.log("propPath:" + this.propPath);
				
				if(window.CallNativeWithJSON != null)
				{
					window.CallNativeWithJSON(JSON.stringify({ func: "PropertyChanged", args: [ this.propPath, $(this).val() ] }));
				}
			}
        }
    });
	
	
	
	$(document).on("change", "select", function(e){
        console.log("select cahnged");
		
		if("propPath" in this)
		{
			console.log("propPath:" + this.propPath);
			
			if(window.CallNativeWithJSON != null)
			{
				window.CallNativeWithJSON(JSON.stringify({ func: "PropertyChanged", args: [ this.propPath, $(this).val() ] }));
			}
		}
    });
	
	function UpdateObjectProperties(InObjectJSONStr, InObjectTypeInfoStr)
	{
		const objectData = JSON.parse(InObjectJSONStr);	
		const subTypeObj = JSON.parse(InObjectTypeInfoStr);	
		generateObjTable("#objProp",objectData,subTypeObj);
	}
	
	function detectBlur() 
	{
		console.log("detectBlur");
	}

	function detectFocus() 
	{
		console.log("detectFocus");
	}

	window.addEventListener ? window.addEventListener('focus', detectFocus, true) : window.attachEvent('onfocusout', detectFocus);  
    window.addEventListener ? window.addEventListener('blur', detectBlur, true) : window.attachEvent('onblur', detectBlur);
	
	if("RegisterJSFunction" in window)
		window.RegisterJSFunction("UpdateObjectProperties", UpdateObjectProperties);
	
	</script>

    </body>
	
</html>
